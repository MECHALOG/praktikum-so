#include <stdio.h>      /* untuk printf, perror */
#include <unistd.h>     /* untuk fork, execl, getpid, getppid, sleep */
#include <stdlib.h>     /* untuk exit */
#include <sys/wait.h>   /* untuk wait */

int main() {
    /* Cetak header singkat (bisa dihapus jika ingin output minimal) */
    printf("Program gabungan Praktikum 3 & 4 (fork, exec, wait, orphan)\n");
    printf("PID parent utama: %d\n\n", getpid());

    /* pid akan menampung nilai return fork():
       - <0 : fork gagal
       - 0  : sedang di proses child
       - >0 : sedang di proses parent (nilai adalah PID child) */
    pid_t pid = fork();

    /* Cek apakah fork gagal */
    if (pid < 0) {
        /* jika fork gagal, tampilkan pesan error dan keluar */
        perror("Fork gagal");
        exit(1);
    }

    /* Jika ini jalan pada proses child (pid == 0) */
    if (pid == 0) {
        /* --- Di dalam CHILD 1 --- */

        /* Tampilkan informasi singkat ke terminal (opsional) */
        printf("[CHILD 1] PID: %d, PPID: %d\n", getpid(), getppid());

        /* Panggil execl untuk mengganti proses child ini menjadi program /bin/ls
           Argumen execl:
             - path lengkap program: "/bin/ls"
             - argv[0] untuk program baru: "ls"
             - parameter berikutnya: "-l"
             - terminator NULL
           Jika execl berhasil, proses child tidak kembali ke baris setelah execl.
           Jika execl gagal, kode setelah execl tetap dieksekusi. */
        execl("/bin/ls", "ls", "-l", NULL);

        /* Jika execl gagal, tampilkan pesan dan exit dengan kode error */
        perror("execl gagal pada CHILD 1");
        exit(1);
    }

    /* Jika ini jalan pada proses parent (pid > 0) */
    /* Parent menunggu child pertama selesai agar sinkron */
    wait(NULL); /* wait(NULL) membuat parent menunggu hingga salah satu child selesai */
    /* Setelah wait kembali, parent melanjutkan eksekusi di sini */
    printf("[PARENT] Child 1 selesai, lanjut membuat Child 2 (orphan demo)\n\n");

    /* Buat child kedua */
    pid_t pid2 = fork();

    /* Cek gagal/tidak */
    if (pid2 < 0) {
        /* Jika fork gagal, laporkan dan keluar */
        perror("Fork gagal (child2)");
        exit(1);
    }

    if (pid2 == 0) {
        /* --- Di dalam CHILD 2 --- */

        /* Tampilkan PID dan PPID sebelum menjadi orphan (opsional) */
        printf("[CHILD 2 - sebelum sleep] PID: %d, PPID: %d\n", getpid(), getppid());

        /* Sleep cukup lama supaya parent bisa exit terlebih dahulu.
           Karena parent akan exit setelah fork() ini, child akan menjadi orphan
           dan PPID child akan berubah (biasanya menjadi 1 atau pid dari init/systemd). */
        sleep(3);

        /* Setelah sleep, tampilkan PPID baru untuk menunjukkan adopsi oleh init/systemd */
        printf("[CHILD 2 - setelah sleep] PID: %d, PPID (baru): %d\n", getpid(), getppid());

        /* Child selesai */
        exit(0);
    }

    /* --- Kembali di PARENT setelah membuat child2 --- */

    /* Parent sengaja tidak menunggu child2 (tidak memanggil wait untuk child2)
       sehingga parent akan exit terlebih dahulu -> child2 menjadi orphan. */
    printf("[PARENT] Saya akan exit sekarang agar Child 2 menjadi ORPHAN.\n");

    /* Sleep singkat agar output teratur (opsional) */
    sleep(1);

    /* Parent keluar di sini; child2 masih berjalan (sleep 3) dan akan diadopsi oleh init/systemd */
    exit(0);

    /* catatan: kode di bawah tidak akan tercapai karena exit(0) di atas.
       Ditulis di sini hanya sebagai penutup fungsi main. */
    return 0;
}
